"""Provide common utils for statechart components."""

from functools import singledispatchmethod
from typing import TYPE_CHECKING, Any, Union

# from superstate.exception import InvalidAction  # InvalidConfig
from superstate.model import Assign, ForEach, Log, Raise
from superstate.provider.base import ExecutorBase

# from superstate.utils import lookup_subclasses

if TYPE_CHECKING:
    from superstate.machine import StateChart
    from superstate.model import Action


class Executor(ExecutorBase):
    """Provide runutor for action actions."""

    ctx: 'StateChart'

    @singledispatchmethod
    def exec(
        self, action: Union['Action', str], *args: Any, **kwargs: Any
    ) -> None:
        """Evaluate action."""
        raise NotImplementedError(
            'datamodel does not support provided action type'
        )

    @exec.register
    def _(self, action: Assign) -> None:
        """Evaluate action."""
        # The <assign> element is used to modify the data model.

    @exec.register
    def _(self, action: ForEach) -> None:
        """Evaluate action."""
        # The <foreach> element allows an SCXML application to iterate through
        # a collection in the data model and to execute the actions contained
        # within it for each item in the collection.

    @exec.register
    def _(self, action: Log) -> None:
        """Evaluate action."""
        # <log> allows an application to generate a logging or debug message.

    @exec.register
    def _(self, action: Raise) -> None:
        """Evaluate raise action."""
        # The <raise> element raises an event in the current SCXML session.
        # Note that the event will not be processed until the current block
        # of executable content has completed and all events that are already
        # in the internal event queue have been processed. For example, suppose
        # the <raise> element occurs first in the <onentry> handler of state S
        # followed by executable content elements ec1 and ec2. If event e1 is
        # already in the internal event queue when S is entered, the event
        # generated by <raise> will not be processed until ec1 and ec2 have
        # finished execution and e1 has been processed.

    @exec.register
    def _(self, action: str) -> None:
        """Evaluate action."""
        local = {
            x: (
                getattr(self.ctx, x)
                if callable(x)
                else lambda v, x=x: setattr(self.ctx, x, v)
            )
            for x in dir(self.ctx)
            if not x.startswith('_') and x not in ('ctx', 'run')
        }

        code = compile(action, '<string>', 'exec')

        for name in code.co_names:
            if name not in local:
                raise NameError(f'Use of {name} not allowed')
        # pylint: disable-next=exec-used
        exec(code, {'__builtins__': {}}, local)
